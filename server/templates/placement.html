<!doctype html>
<title>Greenworld - Guild placement</title>
<link rel="stylesheet" href="{{ url_for('static', filename = 'style.css') }}"/>
{% include "macros/scripting.html" %}
{% include "macros/header.html" %}

<canvas id="canvas"></canvas>
<br/>
<select id="algorithm" onchange="calculate()">
    <option value="geometric">Triangulation</option>
    <option value="dynamic">Force Graph</option>
</select>
<br/>
{% import 'macros/search.html' as lookup %}
{{ lookup.render(None, '(plant) => `<a onclick=\"add_plant(\'${plant.id}\', \'${plant.name}\', \'${plant.species}\')\">${plant.name} (${plant.species})</a>`') }}
<div id="plants"></div>

<script>
    const BUFFER_X = 100;
    const BUFFER_Y = 50;
    const VIEW_X = 1000;
    const VIEW_Y = 500;

    // Run the algorithm when the page loads
    window.gw_init = function() {
        calculate();
    }

    function add_plant(id, name, species) {
        gw.placement.addPlant({ id, name, species, uid: 0 });
        calculate();
    }

    function drop_plant(uid) {
        gw.placement.dropPlant(uid);
        calculate();
    }

    // Calculates and renders guild plant positions
    async function calculate() {
        const canvas = document.getElementById('canvas');
        const plantList = document.getElementById('plants');
        const algorithmType = document.getElementById('algorithm').value;
        const guild = await gw.placement.calculate(algorithmType);
        resetRender(canvas, plantList);
        if (guild !== null) {
            listPlants(plantList, guild);
            drawGuild(canvas, guild);
        }
    }

    // Resets what's visible on the canvas
    function resetRender(canvas, plantList) {
        const ctx = canvas.getContext('2d');
        if (ctx === null) {
            return;
        }
        canvas.width = VIEW_X + (BUFFER_X * 2);
        canvas.height = VIEW_Y + (BUFFER_Y * 2);
        ctx.font = '20px sans-serif';
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        plantList.innerHTML = '';
    }

    // Draws guild representation to the canvas
    function drawGuild(canvas, guild) {
        const ctx = canvas.getContext('2d');
        if (ctx === null) {
            return;
        }

        // Calculate labels
        const labels = [];
        const dx = -guild.bounds.upperLeft.x;
        const dy = -guild.bounds.upperLeft.y;
        const scale = Math.min(
            VIEW_X / (guild.bounds.lowerRight.x - guild.bounds.upperLeft.x),
            VIEW_Y / (guild.bounds.lowerRight.y - guild.bounds.upperLeft.y)
        );

        // Draw lines
        for (let x = Math.floor(guild.bounds.upperLeft.x); x < Math.ceil(guild.bounds.lowerRight.x); x++) {
            ctx.fillStyle = x === 0 ? '#000000' : '#cccccc';
            const pos = (x + dx) * scale + BUFFER_X;
            if (pos < BUFFER_X || pos > VIEW_X + BUFFER_X) {
                continue;
            }
            const h = Math.min((Math.ceil(guild.bounds.lowerRight.y) + dy) * scale, VIEW_Y);
            ctx.fillRect(pos, BUFFER_Y, 1, h);
        }
        for (let y = Math.floor(guild.bounds.upperLeft.y); y < Math.ceil(guild.bounds.lowerRight.y); y++) {
            ctx.fillStyle = y === 0 ? '#000000' : '#cccccc';
            const pos = (y + dy) * scale + BUFFER_Y;
            if (pos < BUFFER_Y || pos > VIEW_Y + BUFFER_Y) {
                continue;
            }
            const w = Math.min((Math.ceil(guild.bounds.lowerRight.x) + dx) * scale, VIEW_X);
            ctx.fillRect(BUFFER_X, pos, w, 1);
        }

        // Draw plants
        ctx.fillStyle = '#00ff00';
        for (const p of guild.plants) {
            const x = (p.x + dx) * scale + BUFFER_X;
            const y = (p.y + dy) * scale + BUFFER_Y;
            ctx.beginPath();
            ctx.arc(x, y, 10, 0, Math.PI * 2);
            ctx.fill();
            labels.push({ text: `${p.uid}`, x, y: y + 5 });
        }

        // Draw labels
        ctx.fillStyle = '#000000';
        for (const l of labels) {
            const metrics = ctx.measureText(l.text);
            ctx.fillText(l.text, l.x - metrics.width / 2, l.y);
        }
    }

    function listPlants(plantList, guild) {
        const items = [];
        for (const p of guild.plants) {
            const x = Math.round(p.x * 100) / 100;
            const y = Math.round(p.y * 100) / 100;
            items.push([p.uid, `${p.uid}) ${p.name} (${p.species}) at (${x}m, ${y}m)`]);
        }
        for (const p of guild.excluded) {
            items.push([p.uid, `${p.uid}) <s>${p.name} (${p.species})</s>`]);
        }
        plantList.innerHTML += items
            .sort((x, y) => x[0] - y[0])
            .map((x) => `<p><button onclick='drop_plant(${x[0]})'>Drop</button> ${x[1]}</p>`)
            .join('');
    }
</script>
