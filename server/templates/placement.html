<!doctype html>
<title>Greenworld - Guild placement</title>
<link rel="stylesheet" href="{{ url_for('static', filename = 'style.css') }}"/>
{% include "macros/scripting.html" %}
{% include "macros/header.html" %}

<canvas id="canvas"></canvas>
<br/>
{% import 'macros/search.html' as lookup %}
{{ lookup.render(None, '(plant) => `<a onclick=\"gw.placement.addPlant(\'${plant.id}\', \'${plant.name}\', \'${plant.species}\')\">${plant.name} (${plant.species})</a>`') }}
<button onclick="gw.placement.calculate()">Place Guild</button>
<div id="plants"></div>

<script>
    const BUFFER_X = 100;
    const BUFFER_Y = 50;
    const VIEW_X = 1000;
    const VIEW_Y = 500;

    // Run the algorithm when the page loads
    function gw_init() {
        calculate();
    }

    gw.wrapper.refreshPlantList = function() {
        let html = '';
        for (const a in gw.placement.plants) {
            const plant = gw.placement.plants[a];
            html += `<p>${a + 1}) ${plant.name} (${plant.species}) <button onclick='gw.placement.dropPlant(${a})'>Drop</button></p>`;
        }
        document.getElementById('plants').innerHTML = html;
    }

    // Calculates and renders guild plant positions
    async function calculate() {
        const canvas = document.getElementById('canvas');
        const plantList = document.getElementById('plants');
        const algorithmType = document.getElementById('algorithm').value;
        const guild = await gw.placement.calculate(algorithmType);
        resetRender(canvas, plantList);
        if (guild !== null) {
            listPlants(plantList, guild);
            drawGuild(canvas, guild);
        }
    }

    // Resets what's visible on the canvas
    function resetRender(canvas, plantList) {
        const ctx = canvas.getContext('2d');
        if (ctx === null) {
            return;
        }
        canvas.width = VIEW_X + (BUFFER_X * 2);
        canvas.height = VIEW_Y + (BUFFER_Y * 2);
        ctx.font = '20px sans-serif';
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        plantList.innerHTML = '';
    }

    // Draws guild representation to the canvas
    function drawGuild(canvas, guild) {
        const ctx = canvas.getContext('2d');
        if (ctx === null) {
            return;
        }

        // Calculate labels
        const labels = [];
        const dx = -guild.bounds.upperLeft.x;
        const dy = -guild.bounds.upperLeft.y;
        const scale = Math.min(
            VIEW_X / (guild.bounds.lowerRight.x - guild.bounds.upperLeft.x),
            VIEW_Y / (guild.bounds.lowerRight.y - guild.bounds.upperLeft.y)
        );

        // Draw lines
        for (let x = Math.floor(guild.bounds.upperLeft.x); x < Math.ceil(guild.bounds.lowerRight.x); x++) {
            ctx.fillStyle = x === 0 ? '#000000' : '#cccccc';
            const pos = (x + dx) * scale + BUFFER_X;
            if (pos < BUFFER_X || pos > VIEW_X + BUFFER_X) {
                continue;
            }
            const h = Math.min((Math.ceil(guild.bounds.lowerRight.y) + dy) * scale, VIEW_Y);
            ctx.fillRect(pos, BUFFER_Y, 1, h);
        }
        for (let y = Math.floor(guild.bounds.upperLeft.y); y < Math.ceil(guild.bounds.lowerRight.y); y++) {
            ctx.fillStyle = y === 0 ? '#000000' : '#cccccc';
            const pos = (y + dy) * scale + BUFFER_Y;
            if (pos < BUFFER_Y || pos > VIEW_Y + BUFFER_Y) {
                continue;
            }
            const w = Math.min((Math.ceil(guild.bounds.lowerRight.x) + dx) * scale, VIEW_X);
            ctx.fillRect(BUFFER_X, pos, w, 1);
        }

        // Draw plants
        ctx.fillStyle = '#00ff00';
        for (const p of guild.plants) {
            const x = (p.x + dx) * scale + BUFFER_X;
            const y = (p.y + dy) * scale + BUFFER_Y;
            ctx.beginPath();
            ctx.arc(x, y, 10, 0, Math.PI * 2);
            ctx.fill();
            labels.push({ text: `${p.uid}`, x, y: y + 5 });
        }

        // Draw labels
        ctx.fillStyle = '#000000';
        for (const l of labels) {
            const metrics = ctx.measureText(l.text);
            ctx.fillText(l.text, l.x - metrics.width / 2, l.y);
        }
    }
</script>
