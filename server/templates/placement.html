<!doctype html>
<title>Greenworld - Guild placement</title>
<link rel="stylesheet" href="{{ url_for('static', filename = 'style.css') }}"/>
{% include "macros/scripting.html" %}
{% include "macros/header.html" %}

<canvas id="canvas"></canvas>
<br/>
{% import 'macros/search.html' as lookup %}
{{ lookup.render(None, '(plant) => `<a onclick=\"gw.placement.addPlant(\'${plant.id}\', \'${plant.name}\', \'${plant.species}\')\">${plant.name} (${plant.species})</a>`') }}
<button onclick="gw.placement.calculate()">Place Guild</button>
<div id="plants"></div>

<script>

    function gw_init() {

        // Updates the list of user-selected plants in the UI
        gw.wrapper.refreshPlantList = function() {
            let html = '';
            for (let a = 0; a < gw.placement.plants.length; a++) {
                const plant = gw.placement.plants[a];
                html += `<p>${a + 1}) ${plant.name} (${plant.species}) <button onclick='gw.placement.dropPlant(${a})'>Drop</button></p>`;
            }
            document.getElementById('plants').innerHTML = html;
        }

        // Draws guild representation to the canvas
        gw.wrapper.drawGuildPlacement = function(points) {
            const BUFFER_X = 100;
            const BUFFER_Y = 50;
            const VIEW_X = 1000;
            const VIEW_Y = 500;
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = VIEW_X + (BUFFER_X * 2);
            canvas.height = VIEW_Y + (BUFFER_Y * 2);
            ctx.font = '20px sans-serif';
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Calculate bounds and view
            const bounds = {
                upperLeft: {
                    x: Infinity,
                    y: Infinity
                },
                lowerRight: {
                    x: -Infinity,
                    y: -Infinity
                }
            };
            for (const p of points) {
                bounds.upperLeft.x = Math.min(bounds.upperLeft.x, p.x);
                bounds.upperLeft.y = Math.min(bounds.upperLeft.y, p.y);
                bounds.lowerRight.x = Math.max(bounds.lowerRight.x, p.x);
                bounds.lowerRight.y = Math.max(bounds.lowerRight.y, p.y);
            }
            const scale = Math.min(
                VIEW_X / (bounds.lowerRight.x - bounds.upperLeft.x),
                VIEW_Y / (bounds.lowerRight.y - bounds.upperLeft.y)
            );
            const dx = BUFFER_X - (bounds.upperLeft.x * scale);
            const dy = BUFFER_Y - (bounds.upperLeft.y * scale);

            // Draw lines
            for (let x = Math.floor(bounds.upperLeft.x); x <= Math.ceil(bounds.lowerRight.x); x++) {
                ctx.fillStyle = x === 0 ? '#000000' : '#cccccc';
                ctx.fillRect((x * scale) + dx, BUFFER_Y, 1, VIEW_Y);
            }
            for (let y = Math.floor(bounds.upperLeft.y); y <= Math.ceil(bounds.lowerRight.y); y++) {
                ctx.fillStyle = y === 0 ? '#000000' : '#cccccc';
                ctx.fillRect(BUFFER_X, (y * scale) + dy, VIEW_X, 1);
            }

            // Draw plants
            for (let a = 0; a < points.length; a++) {
                const p = points[a];
                const cx = (p.x * scale) + dx;
                const cy = (p.y * scale) + dy;
                ctx.fillStyle = '#00ff00';
                ctx.beginPath();
                ctx.arc(cx, cy, 0.166 * scale, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000000';
                ctx.fillText(a + 1, cx - 10, cy);
            }
        }

        // Run the algorithm when the page loads
        gw.wrapper.refreshPlantList();
        gw.placement.calculate();
    }
</script>
